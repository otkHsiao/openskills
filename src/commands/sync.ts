import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, unlinkSync } from 'fs';
import { dirname, basename, join } from 'path';
import chalk from 'chalk';
import { checkbox } from '@inquirer/prompts';
import { ExitPromptError } from '@inquirer/core';
import { findAllSkills } from '../utils/skills.js';
import { generateSkillsXml, replaceSkillsSection, parseCurrentSkills, removeSkillsSection } from '../utils/agents-md.js';
import type { Skill } from '../types.js';

export interface SyncOptions {
  yes?: boolean;
  output?: string;
}

const ROO_COMMAND_DIR = '.roo/commands';
const OPENSKILLS_MARKER = '<!-- Generated by openskills - do not edit -->';

/**
 * Escape quotes in YAML string values
 */
function escapeYamlString(str: string): string {
  // Replace double quotes with escaped double quotes
  return str.replace(/"/g, '\\"');
}

/**
 * Generate Roo command file content for a skill
 */
function generateRooCommandContent(skill: Skill): string {
  const escapedDescription = escapeYamlString(skill.description);
  return `---
description: "${escapedDescription}"
---

${OPENSKILLS_MARKER}

Use the skill \`${skill.name}\` to complete this task.

Invoke: \`npx openskills read ${skill.name}\`
`;
}

/**
 * Check if a file was created by openskills
 */
function isOpenskillsFile(filePath: string): boolean {
  try {
    const content = readFileSync(filePath, 'utf-8');
    return content.includes(OPENSKILLS_MARKER);
  } catch {
    return false;
  }
}

/**
 * Sync skills to .roo/command/ directory
 */
function syncRooCommands(skills: Skill[]): void {
  // Create .roo/command/ directory if it doesn't exist
  if (!existsSync(ROO_COMMAND_DIR)) {
    mkdirSync(ROO_COMMAND_DIR, { recursive: true });
  }

  // Get existing command files
  const existingFiles = existsSync(ROO_COMMAND_DIR)
    ? readdirSync(ROO_COMMAND_DIR).filter(f => f.endsWith('.md'))
    : [];
  
  const skillNames = new Set(skills.map(s => `${s.name}.md`));
  
  // Remove command files that were created by openskills but are no longer in the selected skills
  for (const file of existingFiles) {
    const filePath = join(ROO_COMMAND_DIR, file);
    // Only remove files created by openskills (has marker) and not in selected skills
    if (!skillNames.has(file) && isOpenskillsFile(filePath)) {
      unlinkSync(filePath);
    }
  }

  // Write command files for selected skills
  for (const skill of skills) {
    const filePath = join(ROO_COMMAND_DIR, `${skill.name}.md`);
    const content = generateRooCommandContent(skill);
    writeFileSync(filePath, content);
  }
}

/**
 * Sync installed skills to a markdown file
 */
export async function syncAgentsMd(options: SyncOptions = {}): Promise<void> {
  const outputPath = options.output || 'AGENTS.md';
  const outputName = basename(outputPath);

  // Validate output file is markdown
  if (!outputPath.endsWith('.md')) {
    console.error(chalk.red('Error: Output file must be a markdown file (.md)'));
    process.exit(1);
  }

  // Create file if it doesn't exist
  if (!existsSync(outputPath)) {
    const dir = dirname(outputPath);
    if (dir && dir !== '.' && !existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    writeFileSync(outputPath, `# ${outputName.replace('.md', '')}\n\n`);
    console.log(chalk.dim(`Created ${outputPath}`));
  }

  let skills = findAllSkills();

  if (skills.length === 0) {
    console.log('No skills installed. Install skills first:');
    console.log(`  ${chalk.cyan('npx openskills install anthropics/skills --project')}`);
    return;
  }

  // Interactive mode by default (unless -y flag)
  if (!options.yes) {
    try {
      // Parse what's currently in output file
      const content = readFileSync(outputPath, 'utf-8');
      const currentSkills = parseCurrentSkills(content);

      // Sort: project first
      const sorted = skills.sort((a, b) => {
        if (a.location !== b.location) {
          return a.location === 'project' ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
      });

      const choices = sorted.map((skill) => ({
        name: `${chalk.bold(skill.name.padEnd(25))} ${skill.location === 'project' ? chalk.blue('(project)') : chalk.dim('(global)')}`,
        value: skill.name,
        description: skill.description.slice(0, 70),
        // Pre-select if currently in file, otherwise default to project skills
        checked: currentSkills.includes(skill.name) || (currentSkills.length === 0 && skill.location === 'project'),
      }));

      const selected = await checkbox({
        message: `Select skills to sync to ${outputName}`,
        choices,
        pageSize: 15,
      });

      if (selected.length === 0) {
        // User unchecked everything - remove skills section
        const content = readFileSync(outputPath, 'utf-8');
        const updated = removeSkillsSection(content);
        writeFileSync(outputPath, updated);
        // Also sync empty skills to Roo commands (will remove all skill-related commands)
        syncRooCommands([]);
        console.log(chalk.green(`✅ Removed all skills from ${outputName} and .roo/command/`));
        return;
      }

      // Filter skills to selected ones
      skills = skills.filter((s) => selected.includes(s.name));
    } catch (error) {
      if (error instanceof ExitPromptError) {
        console.log(chalk.yellow('\n\nCancelled by user'));
        process.exit(0);
      }
      throw error;
    }
  }

  const xml = generateSkillsXml(skills);
  const content = readFileSync(outputPath, 'utf-8');
  const updated = replaceSkillsSection(content, xml);

  writeFileSync(outputPath, updated);

  // Sync to .roo/command/ directory
  syncRooCommands(skills);

  const hadMarkers =
    content.includes('<skills_system') || content.includes('<!-- SKILLS_TABLE_START -->');

  if (hadMarkers) {
    console.log(chalk.green(`✅ Synced ${skills.length} skill(s) to ${outputName} and .roo/command/`));
  } else {
    console.log(chalk.green(`✅ Added skills section to ${outputName} and .roo/command/ (${skills.length} skill(s))`));
  }
}
