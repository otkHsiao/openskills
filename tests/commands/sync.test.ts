import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdirSync, writeFileSync, readFileSync, rmSync, existsSync, readdirSync } from 'fs';
import { join, dirname, basename } from 'path';
import { tmpdir } from 'os';

// Test the sync utility functions directly
import {
  generateSkillsXml,
  replaceSkillsSection,
  parseCurrentSkills,
  removeSkillsSection,
} from '../../src/utils/agents-md.js';
import type { Skill } from '../../src/types.js';

// Constants mirroring sync.ts implementation
const OPENSKILLS_MARKER = '<!-- Generated by openskills - do not edit -->';

// Helper function to generate Roo command content (mirrors sync.ts implementation)
function generateRooCommandContent(skill: Skill): string {
  return `${OPENSKILLS_MARKER}
Use the skill \`${skill.name}\` to complete this task.

Invoke: \`npx openskills read ${skill.name}\`

${skill.description}
`;
}

// Helper function to check if file was created by openskills
function isOpenskillsFile(filePath: string): boolean {
  try {
    const content = readFileSync(filePath, 'utf-8');
    return content.startsWith(OPENSKILLS_MARKER);
  } catch {
    return false;
  }
}

const testId = Math.random().toString(36).slice(2);
const testTempDir = join(tmpdir(), `openskills-sync-test-${testId}`);

describe('sync utilities (agents-md.ts)', () => {
  describe('generateSkillsXml', () => {
    it('should generate valid XML for skills', () => {
      const skills: Skill[] = [
        { name: 'pdf', description: 'PDF manipulation', location: 'project', path: '/path/to/pdf' },
        { name: 'xlsx', description: 'Spreadsheet editing', location: 'global', path: '/path/to/xlsx' },
      ];

      const xml = generateSkillsXml(skills);

      expect(xml).toContain('<skills_system priority="1">');
      expect(xml).toContain('<name>pdf</name>');
      expect(xml).toContain('<description>PDF manipulation</description>');
      expect(xml).toContain('<location>project</location>');
      expect(xml).toContain('<name>xlsx</name>');
      expect(xml).toContain('<description>Spreadsheet editing</description>');
      expect(xml).toContain('<location>global</location>');
      expect(xml).toContain('</skills_system>');
    });

    it('should include usage instructions', () => {
      const skills: Skill[] = [
        { name: 'test', description: 'Test skill', location: 'project', path: '/path' },
      ];

      const xml = generateSkillsXml(skills);

      expect(xml).toContain('<usage>');
      expect(xml).toContain('npx openskills read');
      expect(xml).toContain('</usage>');
    });

    it('should generate empty skills section for empty array', () => {
      const xml = generateSkillsXml([]);

      expect(xml).toContain('<available_skills>');
      expect(xml).toContain('</available_skills>');
    });
  });

  describe('parseCurrentSkills', () => {
    it('should parse skill names from existing content', () => {
      const content = `
# AGENTS.md

<skills_system>
<available_skills>
<skill>
<name>pdf</name>
<description>PDF tools</description>
</skill>
<skill>
<name>xlsx</name>
<description>Excel tools</description>
</skill>
</available_skills>
</skills_system>
`;

      const skills = parseCurrentSkills(content);

      expect(skills).toContain('pdf');
      expect(skills).toContain('xlsx');
      expect(skills).toHaveLength(2);
    });

    it('should return empty array for content without skills', () => {
      const content = '# AGENTS.md\n\nNo skills here.';

      const skills = parseCurrentSkills(content);

      expect(skills).toHaveLength(0);
    });

    it('should handle malformed XML gracefully', () => {
      const content = '<skill><name>broken';

      const skills = parseCurrentSkills(content);

      expect(Array.isArray(skills)).toBe(true);
    });
  });

  describe('replaceSkillsSection', () => {
    it('should replace existing skills_system section', () => {
      const content = `# AGENTS.md

<skills_system priority="1">
OLD CONTENT
</skills_system>

Other content`;

      const newSection = '<skills_system priority="1">NEW CONTENT</skills_system>';
      const result = replaceSkillsSection(content, newSection);

      expect(result).toContain('NEW CONTENT');
      expect(result).not.toContain('OLD CONTENT');
      expect(result).toContain('Other content');
    });

    it('should replace HTML comment markers', () => {
      const content = `# AGENTS.md

<!-- SKILLS_TABLE_START -->
OLD SKILLS
<!-- SKILLS_TABLE_END -->

Footer`;

      const newSection = '<skills_system>NEW SKILLS</skills_system>';
      const result = replaceSkillsSection(content, newSection);

      expect(result).toContain('NEW SKILLS');
      expect(result).not.toContain('OLD SKILLS');
    });

    it('should append to end if no markers found', () => {
      const content = '# AGENTS.md\n\nSome content.';
      const newSection = '<skills_system>SKILLS</skills_system>';

      const result = replaceSkillsSection(content, newSection);

      expect(result).toContain('Some content.');
      expect(result).toContain('<skills_system>SKILLS</skills_system>');
    });
  });

  describe('removeSkillsSection', () => {
    it('should remove skills_system section', () => {
      const content = `# AGENTS.md

<skills_system priority="1">
Skills content
</skills_system>

Footer`;

      const result = removeSkillsSection(content);

      expect(result).not.toContain('Skills content');
      expect(result).toContain('Footer');
    });

    it('should handle content without skills section', () => {
      const content = '# AGENTS.md\n\nNo skills.';

      const result = removeSkillsSection(content);

      expect(result).toBe(content);
    });
  });
});

describe('sync --output flag logic', () => {
  beforeEach(() => {
    mkdirSync(testTempDir, { recursive: true });
  });

  afterEach(() => {
    rmSync(testTempDir, { recursive: true, force: true });
  });

  describe('output path validation', () => {
    it('should accept .md files', () => {
      const validPaths = [
        'AGENTS.md',
        'custom.md',
        '.ruler/AGENTS.md',
        'docs/rules.md',
      ];

      for (const path of validPaths) {
        expect(path.endsWith('.md')).toBe(true);
      }
    });

    it('should reject non-.md files', () => {
      const invalidPaths = [
        'AGENTS.txt',
        'rules.yaml',
        'config.json',
        'noextension',
      ];

      for (const path of invalidPaths) {
        expect(path.endsWith('.md')).toBe(false);
      }
    });
  });

  describe('auto-create file behavior', () => {
    it('should create file with heading if not exists', () => {
      const outputPath = join(testTempDir, 'NEW-FILE.md');

      // Simulate the auto-create logic
      if (!existsSync(outputPath)) {
        const outputName = basename(outputPath);
        writeFileSync(outputPath, `# ${outputName.replace('.md', '')}\n\n`);
      }

      expect(existsSync(outputPath)).toBe(true);
      const content = readFileSync(outputPath, 'utf-8');
      expect(content).toBe('# NEW-FILE\n\n');
    });

    it('should create nested directories if needed', () => {
      const outputPath = join(testTempDir, 'nested', 'deep', 'AGENTS.md');
      const dir = dirname(outputPath);

      // Simulate the directory creation logic
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
      writeFileSync(outputPath, '# AGENTS\n\n');

      expect(existsSync(outputPath)).toBe(true);
      expect(existsSync(dir)).toBe(true);
    });

    it('should preserve existing file content', () => {
      const outputPath = join(testTempDir, 'existing.md');
      const existingContent = '# Existing Content\n\nImportant stuff here.';
      writeFileSync(outputPath, existingContent);

      // Read existing content
      const content = readFileSync(outputPath, 'utf-8');

      expect(content).toBe(existingContent);
    });
  });

  describe('default output path', () => {
    it('should default to AGENTS.md', () => {
      const defaultPath = 'AGENTS.md';
      expect(defaultPath).toBe('AGENTS.md');
    });
  });
});

describe('Roo command sync (.roo/command/)', () => {
  beforeEach(() => {
    mkdirSync(testTempDir, { recursive: true });
  });

  afterEach(() => {
    rmSync(testTempDir, { recursive: true, force: true });
  });

  describe('generateRooCommandContent', () => {
    it('should generate valid command content for a skill', () => {
      const skill: Skill = {
        name: 'pdf-tools',
        description: 'PDF manipulation and conversion tools',
        location: 'project',
        path: '/path/to/pdf-tools',
      };

      const content = generateRooCommandContent(skill);

      expect(content).toContain(OPENSKILLS_MARKER);
      expect(content).toContain('Use the skill `pdf-tools` to complete this task.');
      expect(content).toContain('Invoke: `npx openskills read pdf-tools`');
      expect(content).toContain('PDF manipulation and conversion tools');
    });

    it('should start with openskills marker', () => {
      const skill: Skill = {
        name: 'test',
        description: 'Test skill',
        location: 'project',
        path: '/path',
      };

      const content = generateRooCommandContent(skill);

      expect(content.startsWith(OPENSKILLS_MARKER)).toBe(true);
    });

    it('should handle skills with special characters in name', () => {
      const skill: Skill = {
        name: 'my-special_skill',
        description: 'A skill with special chars',
        location: 'global',
        path: '/path/to/skill',
      };

      const content = generateRooCommandContent(skill);

      expect(content).toContain('`my-special_skill`');
      expect(content).toContain('npx openskills read my-special_skill');
    });
  });

  describe('Roo command directory creation', () => {
    it('should create .roo/command/ directory structure', () => {
      const rooCommandDir = join(testTempDir, '.roo', 'command');
      
      // Simulate directory creation logic from sync.ts
      if (!existsSync(rooCommandDir)) {
        mkdirSync(rooCommandDir, { recursive: true });
      }

      expect(existsSync(rooCommandDir)).toBe(true);
    });

    it('should write skill command files to .roo/command/', () => {
      const rooCommandDir = join(testTempDir, '.roo', 'command');
      mkdirSync(rooCommandDir, { recursive: true });

      const skills: Skill[] = [
        { name: 'pdf', description: 'PDF tools', location: 'project', path: '/path/to/pdf' },
        { name: 'xlsx', description: 'Excel tools', location: 'global', path: '/path/to/xlsx' },
      ];

      // Write command files
      for (const skill of skills) {
        const filePath = join(rooCommandDir, `${skill.name}.md`);
        const content = generateRooCommandContent(skill);
        writeFileSync(filePath, content);
      }

      // Verify files were created
      expect(existsSync(join(rooCommandDir, 'pdf.md'))).toBe(true);
      expect(existsSync(join(rooCommandDir, 'xlsx.md'))).toBe(true);

      // Verify content
      const pdfContent = readFileSync(join(rooCommandDir, 'pdf.md'), 'utf-8');
      expect(pdfContent).toContain('Use the skill `pdf` to complete this task.');
      expect(pdfContent).toContain('PDF tools');
    });

    it('should handle empty skills array (remove all command files)', () => {
      const rooCommandDir = join(testTempDir, '.roo', 'command');
      mkdirSync(rooCommandDir, { recursive: true });

      // Create some existing command files
      writeFileSync(join(rooCommandDir, 'old-skill.md'), 'old content');
      
      // After syncing with empty array, the directory should still exist
      expect(existsSync(rooCommandDir)).toBe(true);
    });
  });

  describe('openskills marker detection', () => {
    it('should detect files created by openskills', () => {
      const rooCommandDir = join(testTempDir, '.roo', 'command');
      mkdirSync(rooCommandDir, { recursive: true });

      const skill: Skill = {
        name: 'test-skill',
        description: 'Test description',
        location: 'project',
        path: '/path',
      };

      const filePath = join(rooCommandDir, 'test-skill.md');
      writeFileSync(filePath, generateRooCommandContent(skill));

      expect(isOpenskillsFile(filePath)).toBe(true);
    });

    it('should not detect user-created files as openskills files', () => {
      const rooCommandDir = join(testTempDir, '.roo', 'command');
      mkdirSync(rooCommandDir, { recursive: true });

      const filePath = join(rooCommandDir, 'custom-command.md');
      writeFileSync(filePath, 'This is my custom command');

      expect(isOpenskillsFile(filePath)).toBe(false);
    });

    it('should safely handle deleted skills by removing their command files', () => {
      const rooCommandDir = join(testTempDir, '.roo', 'command');
      mkdirSync(rooCommandDir, { recursive: true });

      // Simulate: openskills created a command file for a skill
      const openskillsFile = join(rooCommandDir, 'deleted-skill.md');
      writeFileSync(openskillsFile, `${OPENSKILLS_MARKER}\nOld skill content`);

      // User also has their own custom command
      const userFile = join(rooCommandDir, 'my-custom.md');
      writeFileSync(userFile, 'My custom command');

      // Verify both exist
      expect(existsSync(openskillsFile)).toBe(true);
      expect(existsSync(userFile)).toBe(true);

      // Verify marker detection
      expect(isOpenskillsFile(openskillsFile)).toBe(true);
      expect(isOpenskillsFile(userFile)).toBe(false);
    });
  });

  describe('Roo command file naming', () => {
    it('should use skill name as filename', () => {
      const skill: Skill = {
        name: 'my-awesome-skill',
        description: 'An awesome skill',
        location: 'project',
        path: '/path',
      };

      const expectedFilename = `${skill.name}.md`;
      expect(expectedFilename).toBe('my-awesome-skill.md');
    });

    it('should create proper .md extension', () => {
      const skillNames = ['pdf', 'xlsx', 'code-review', 'test_skill'];
      
      for (const name of skillNames) {
        const filename = `${name}.md`;
        expect(filename.endsWith('.md')).toBe(true);
      }
    });
  });

  describe('Roo command content format', () => {
    it('should include skill invocation command', () => {
      const skill: Skill = {
        name: 'test-skill',
        description: 'Test description',
        location: 'project',
        path: '/path',
      };

      const content = generateRooCommandContent(skill);

      expect(content).toMatch(/npx openskills read test-skill/);
    });

    it('should include skill description', () => {
      const skill: Skill = {
        name: 'test',
        description: 'This is a detailed description of what the skill does.',
        location: 'global',
        path: '/path',
      };

      const content = generateRooCommandContent(skill);

      expect(content).toContain('This is a detailed description of what the skill does.');
    });
  });
});
